# 树

- 节点的高度：节点到子节点的**最长路径**（边数）
- 节点的深度：根节点到这个节点所经历的**边的个数**
- 节点的层数：节点的深度 + 1
- 树的高度：根节点的高度

高度、层数类比楼层，从下往上数；深度类比鱼塘，从上往下数

## 二叉树

- 满二叉树
- 完全二叉树

## 二叉树的遍历

- 前序遍历（对于任意节点，先打印这个节点，再打印它的左子树，最后打印它的右子树）
- 中序遍历（对于任意节点，先打印它的左子树、再打印它本身，最后打印它的右子树）
- 后序遍历（对于任意节点，先打印它的左子，再打印它的右子树，最后打印它本身）

**二叉树的前、中、后序遍历就是一个递归的过程**

## 二叉查找树

在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值

## 对比散列表

1. 散列表的数据无序存储，二叉查找树只需要中序遍历
2. 散列表扩容耗时多，遇到散列冲突时不稳定，平衡二叉查找树性能非常稳定，时间复杂度稳定在 O(logn)
3. 散列表查找复杂度是常量级，但因为哈希冲突，这个常量不一定比 logn 小
4. 散列表的构造比二叉查找树复杂，考虑的东西多，如散列函数的设计、冲突解决办法、扩容、缩容等，平衡二叉查找树只需要考虑平衡性
