# 堆的应用

## 优先级队列

使用堆实现优先级队列，插入元素相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，相当于取出堆顶元素

1. 合并有序小文件

从 100 个小文件中取字符串进行比较，类似归并排序。使用优先级队列，将各小文件的字符串放到小顶堆中，100 个小文件的 string 组成一个小顶堆，堆顶的元素就是最小的字符串，把这个字符串放入到大文件中，并将其删除，一直循环这个过程

删除堆顶数据和往堆中插入数据复杂度都是 O(logn) 比数组更加高效

2. 高性能定时器

把任务列表设定的时间存储在优先队列中，然后拿队首任务执行时间点与当前时间相减得到 T，设定在 T 秒后执行，T 内定时器不需要做任何事情

当 T 秒过去，取出队首任务执行，再重新计算队首任务执行时间和当前时间的差值，把这个差值作为定时器执行下一个任务需要等待的时间

这样不需要每秒轮询，也不用遍历整个任务列表，提高性能

## 利用堆求 Top K

针对静态数据：维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较，比如数组 `[4，5，3，7，1，8]`，要取前 3 大元素 首先维护一个小顶堆，放入前三个数据，为 `[3，4，5]`； 接着遍历数组到元素 7，比堆顶元素 3 大，将 3 移除，将 7 放入堆中，小顶堆变为 `[4，5，7]`； 接着遍历数组到元素 1，比堆顶元素 4 小，不处理，接着遍历； 接着遍历数组到元素 8，比堆顶元素 4 大，将 4 移除，将 8 放入堆中，小顶堆变为 `[5，7，8]`；

遍历数组需要 `O(n)` 的时间复杂度，一次堆化操作需要 `O(logK)` 的时间复杂度，所以最坏情况下，`n` 个元素都入堆一次，时间复杂度就是 `O(nlogK)`，比快速排序的 `O(nlogn)` 更快

针对动态数据：可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。堆的应用三：利用堆求中位数

## 利用堆求中位数

可以利用两个堆，一个大顶堆、一个小顶堆，实现在动态数据集合中求中位数的操作。插入数据因为需要涉及堆化，所以时间复杂度变成了 `O(logn)`，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 `O(1)`。从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足约定的比例
